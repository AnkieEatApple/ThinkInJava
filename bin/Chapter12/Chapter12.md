##Chapter12、通过异常处理错误
1. Java的基本理念是“结构不佳的代码不能运行”

####12.1 概念
1. 可以降低错误代码的复杂度
2. 如果使用异常，那就不必在方法调用处进行检查，因为一场机制将保证能够捕获这个错误
3. 可以将“描述正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离

####11.2 基本异常
1. “异常情形”，是指阻止当前方法或作用域继续执行的问题
2. “普通问题”，是指当前环境下能得到足够的信息，总能处理这个错误
3. 对于异常情形，当前环境不能继续下去，将问题提交给上一级环境。
4. 发生异常时，异常处理机制接管程序，开始寻找一个恰当的地方来继续执行程序，恰当的地方就是异常处理程序
5. 异常使得我们可以将每件事都当作一个事务来考虑，而异常可以看护这些事物的底线
6. 异常还可以看作是一种内建的恢复系统，因为在程序中可以拥有各种不同的恢复点，如果程序的某部分失败了，异常将“恢复”到程序中的某个已知的稳定点上

#####11.2.1 异常参数
1. 特指抛出异常时的参数
2. 分为两种：一是默认构造器、一是字符串作为参数，可以将相关信息放入异常对象的构造器
3. 能够抛出任意类型的Throwable对象，它是异常类型的根类
4. 对于不同类型的错误，要抛出相应的异常，错误信息可以保存在异常对象内部，或者用异常类的名称来暗示

####12.3 捕获异常
1. 监控区域，一段可能产生异常的代码，并且后面跟着处理这些异常的代码

#####12.3.1 try块
1. 在这个块里“尝试”各种可能产生异常的方法调用

#####12.3.2 异常处理程序
1. catch，异常处理程序，看起来就像是接收一个且仅接受一个特殊类型的参数的方法
2. 当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，进入到catch中执行，此时任务异常的到了处理
3. 异常处理有两种模型：Java支持终止模型，也就是假设程序非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。

####12.4 创建自定义的异常
1. 自定义的异常必须从已有的异常类中继承
2. 编辑器创建了默认的构造器，它将自动调用基类的默认构造器
3. 在异常的处理程序中，调用了Throwable类的声明，Exception即从此类继承的printStackTrace()方法，就像输出中看到的，它将打印“从方法调用处直到异常抛出处”的方法调用序列
4. e.printStackTrace(System.out); 表示自动地被捕获和显示在输出中，但是调用默认的版本e.printStackTrace(); 信息将会被输出到标准的错误流中

#####12.4.1 异常与记录的日志
1. 这里需要单独查找关于异常记录的组建

####12.5 异常说明
1. 异常说明使用了附加的关键字throws，后面接一个所有潜在异常类型的列表，写法如`void f() throws TooBig, TooSmall, DivZero { ... }`
2. 当此方法不会抛出任何异常的时候，出了RuntimeException继承的异常，可以直接写为`void f() { ... }`
3. 可以声明方法将抛出异常，实际上却不抛出，编辑器相信了这个声明，并强制此方法的用户像真的抛出异常的那样使用这个方法。这样的方法的好处是，现将异常占了一个位子，以后就可以抛出这种异常而不用修改现有的代码结构，在定义抽象基类个接口的时候很方便。

####12.6 捕获所有的异常
1. Exception可以捕获所有的异常，所以最好把这个处理程序放在catch的末尾，一方它抢在其他的程序之前，将异常捕获了。
2. Exception是与编程有关的所有的异常类的基类，所以不会含有太多的具体的信息，不过可以调用它从其基类Throwable继承的方法： String getMessage() String getLocalizedMessage() 来获取详细信息，或者用本地语言表示详细信息 String toString()

#####12.6.1 栈轨迹
1. printStackTrace()方法所提供的信息可以通过getStackTrace方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示占中的一桢。
2. 通过`for(StackTraceElement ste : e.getStackTrace())`获取栈中的信息
3. 可以通过`ste.getMethodName()`方法类获取调用的方法名

#####12.6.2 重新抛出异常
1. 将刚捕获的异常重新抛出，已经得到了异常对象的引用，重新抛出的时候会把异常抛给上一级环境中的异常处理程序。
2. `catch(Exception e) { System.out.println("An exception was throw"); throw e; }`
3. 调用fillInStackTrace()的那一行就成了异常的新发生地了

####12.7 Java标准异常
1. Throwable这个Java类被用来表示任何可以作为异常被抛出的类。
2. Throwable对象可以分为两种类型，Error用来表示编译时和系统错误、Exception表示可以被抛出的基本类型，在Java类库中，用户方法以及运行时故障都可能抛出Exception异常
3. 异常一般上来说都是望文知义

####12.8 使用finally进行清理
1. 无论try中是否有异常抛出，他们都得到执行，通常适用于内存回收之外的情况，可以在后面加上finally子句
2. 无论异常是否被抛出，最后finally都可以被执行
3. 对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要
4. 当设计break和continue语句的时候，finally子句也会的得到执行，goto就不能用了
5. 在return之后也可以添加finally，也可以执行

####12.9 异常的限制
1. 覆盖方法的时候，只能抛出在积累方法的异常说明里列出的那些异常，意味着在基类使用的代码应用到其派生类对象的时候，一样可以工作


####12.10 构造器

####12.11 异常匹配
1. 抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就任务异常将得到处理，然后就不再继续处理。
2. 查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配，派生类对象也可以匹配其基类的处理程序。

####12.12 其他可选方式
1. 只有在你知道如何处理的情况下才捕获异常，实际上，异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。
2. 这样可以在一段代码中专注要完成的事情，至于如何处理错误，则放在另一段代码中完成

####12.13 异常使用指南
1. 在恰当的几倍处理问题，应该知道该如何处理的情况下才捕捉异常
2. 解决问题并且重新调用产生异常的方法
3. 进行少许修补，然后绕过异常发生的地方继续执行
4. 用别的数据进行计算，以代替方法预计会返回的值
5. 把当前运行环境下能做的事情尽量做完，然后把相同的异常抛到更高层
6. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层
7. 终止程序
8. 进行简化
9. 让类库和程序更安全

####12.14 总结
1. 异常的处理就是为了可以在某处集中精力处理你要解决的问题，另一处处理你编写这段代码中产生的错误















