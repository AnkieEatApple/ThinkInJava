##Chapter15 泛型 generics
1. 关于泛型

###7.1 擦除的神秘之处
1. 在泛型的代码内部，无法获得任何有关泛型参数类型的信息

```
List<Integer> list = new ArrayList<>();
list.getClass().getTypeParameters();
```
可以通过getTypeParameters()方法获取泛型的类型参数，但是没有什么用处

####7.1 C++的方式
1. 可以定义泛型的边界，通过extends的关键字来限定泛型的上限

```
public class Manipulator<T extends HasF> { // 这个extends就是边界
	private final T obj;

	public Manipulator(final T x) {
		obj = x;
	}

	void manipulate() {
		obj.f();
	}
}
```

####7.2 迁移兼容性
1. 泛型Java语言不是出现时就有的组成部分，所以这种事必须的
2. 基于擦除的实现中，泛型类型被当作第二类类型处理，既不能在某些重要的上下文环境中使用的类型
3. 泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型将被擦除，替换为他们的非泛型上界。例如List<T> 这样的类型注解将被擦除为List，普通类型的变量在为指定边界的情况下将被擦除为Object。
4. Java的泛型支持向后兼容性

####7.3 擦除的问题
1. 擦除的主要正当理由是从非泛化代码到泛化代码转变的过程，以及在不破坏现有类库的情况下，将泛型融入Java语言。


####7.4 边界的动作
1. 对于在泛型中创建数组，使用Array.newInstance()
2. 所以泛型中的所有动作都发生在边界处--对传递进来的值进行额外的编译期的检查，并插入对传递出去的值的转型
3. 这个有助于对擦除的混淆，也就是**边界就是发生动作的地方！**

###8. 擦除的补偿
1. 擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要确切类型信息的操作都将无法工作。
2. 编译器确保类型标签可以匹配泛型参数，`kind.isInstance(arg);`

####8.1 创建类型的实例

1. Java的编辑器不能验证T具有默认的无参构造器。
2. Java中的解决方案时传递一个工厂对象，并且使用它来创建新的实例。
3. 利用`Class.newInstance()`方法创建这个类的对象的时候，这个类中必须有无参的构造方法

####8.2 泛型数组
1. 不能创建泛型数组，一般的解决方案时在任何想要创建泛型数组的地方都适用ArrayList
2. 泛型永远都不可以创建类型的数组，虽然可以编译，但是不能运行。将产生ClassCaseException
3. 数组被创建的时候，数组将会跟踪它们的实际类型，而这个类型是在数组被创建时确定的
4. 数组在创建的时候为Object[]的模式，但是在创建之后，想通过强制向上转型成T[]的类型，这个仍然是不正确的，依旧会报错


###9 边界
1. 边界为用于泛型的参数上设置限制条件
2. 无界泛型的参数调用的方法只可以是那些可以用于Object的方法，我感觉类似于向下转型为指定的类，使用extends关键字

























